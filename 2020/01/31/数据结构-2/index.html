<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Yijun Lin">





<title>Review | 数据结构(2) | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Yijun&#39;s Studio</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Yijun&#39;s Studio</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Review | 数据结构(2)</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Yijun Lin</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 31, 2020&nbsp;&nbsp;14:21:43</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AFComputerScience/">计算机科学与技术ComputerScience</a>
                            
                                <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84DataStructure/">数据结构DataStructure</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><strong>Created Date</strong>: 2020-01-31 14:21:43<br><strong>Last Upgraded Date</strong>: 2020-02-07 14:51:27</p>
<br/>

<h1 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h1><h2 id="树和森林的实现"><a href="#树和森林的实现" class="headerlink" title="树和森林的实现"></a>树和森林的实现</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ul>
<li><p><strong>双亲表示法</strong><br>  Data域 存储结点的数据信息<br>  Parent域 存储结点的双亲在数组中的序号。<br>  实现求双亲操作很方便，但对于求某节点的孩子节点的操作需要查询整个数组，实现求兄弟的操作也比较困难。</p>
</li>
<li><p><strong>孩子表示法</strong></p>
<ol>
<li>多重链表<br>链表中的每个结点包括一个数据域和多个指针域。数据域存储树中结点的自身信息，每个指针指向该结点的一个孩子结点。</li>
<li>数组+单链表<br>一维数组顺序存储树中各节点的信息，并将各结点的孩子信息组成一个单链表。</li>
</ol>
</li>
<li><p><strong>双亲 - 孩子表示法</strong><br>  将各结点的孩子结点组成一个单链表，同时用一维数组顺序存储树中的各节点，数组元素包括结点的自身信息、双亲结点在数组中的序号以及该结点的孩子结点链表的头指针。</p>
</li>
<li><p><strong>孩子 - 兄弟表示法</strong><br>  firstchild data nextsibling<br>  二重链表表示法<br>  查找某结点的孩子结点比较方便，如果在每一个结点中增加一个指向双亲的指针，就可以方便地找到各结点的祖先。</p>
</li>
</ul>
<h3 id="树、森林和二叉树的转换"><a href="#树、森林和二叉树的转换" class="headerlink" title="树、森林和二叉树的转换"></a>树、森林和二叉树的转换</h3><ol>
<li><p>树转化为二叉树<br> 把树当作有序树看待：约定树中每一个结点的孩子结点按从左到右的次序顺序编号。<br> <strong>连线</strong>：树中所有相邻兄弟结点之间加一条线。<br> <strong>删线</strong>：对树中的每一个结点，只保留它与第一个孩子结点之间的连线，删去它与其他孩子结点之间的连线。<br> <strong>美化</strong>：以树的根结点为轴心，将这棵树顺时针转动45度使其层次分明。<br> <em>树作这样的转化所构成的二叉树是唯一的。</em><br> 树转化成的二叉树，其根结点无右子树。</p>
</li>
<li><p>森林转化为二叉树<br> <strong>依次将森林中每棵树转化成相应的二叉树。</strong><br> <strong>从第二棵二叉树开始，依次把当前的二叉树作为前一棵二叉树根结点的右子树，此时所得到的二叉树就是由森林转化得到的二叉树。</strong><br> 森林转化成的二叉树，其根结点有右子树。</p>
</li>
<li><p>二叉树转化为森林<br> <strong>连线</strong>：若结点p是其双亲结点F的 左孩子，则把从结点p延沿右分支所找到的所有结点和结点F用线连起来。<br> <strong>删线</strong>：删除二叉树中所有结点和其右孩子结点之间的连线。<br> <strong>美化</strong>：整理，使结构层次分明。</p>
</li>
</ol>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>指按照某种顺序访问树中的每个结点，并使每个结点被访问一次且只被访问一次。</p>
<ol>
<li><p>树的先根遍历<br>若树为空，遍历结束。否则，<br>访问根结点；<br>按照从左到右的顺序先根遍历根结点的每一棵子树。<br>与二叉树先序遍历结果序列相同。</p>
</li>
<li><p>树的后根遍历<br>若树为空，遍历结束。否则，<br>按照从左到右的顺序后根遍历根结点的每一棵子树；<br>访问根结点。<br>与二叉树中序遍历结果序列相同。</p>
</li>
<li><p>树的层次遍历<br>又称为树的广度遍历。从树的第一层（根结点）开始，自上至下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。<br>借助队列，结构按下述步骤层序遍历树：<br>1）初始化队列，并将根结点入队。<br>2）当队列非空时，取出队头结点p，转步骤3）；如果队列为空，则结束遍历。<br>3）访问取出的结点p；如果结点p有孩子，则依次将它们入队列。<br>4）重复步骤2）、3），直到队列为空。</p>
</li>
</ol>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><ol>
<li><p>森林的先根遍历<br>若森林为空，返回；否则，<br>访问森林中第一棵树的根结点；<br>先根遍历第一棵树的根结点的子树森林；<br>先根遍历除第一棵外其他树组成的森林。<br>与二叉树先序遍历结果序列相同。</p>
</li>
<li><p>森林的中根遍历<br>若森林为空，返回；否则，<br>中根遍历第一棵树的根结点的子树森林；<br>访问森林中第一棵树的根结点；<br>中根遍历除第一棵外其他树组成的森林。<br>与二叉树中序遍历结果序列相同。</p>
</li>
<li><p>森林的后根遍历<br>若森林为空，返回；否则，<br>后根遍历第一棵树的根结点的子树森林；<br>后根遍历除第一棵外其他树组成的森林；<br>访问森林中第一棵树的根结点。<br>与二叉树后序遍历结果序列相同。</p>
</li>
</ol>
<h2 id="等价类及其表示"><a href="#等价类及其表示" class="headerlink" title="等价类及其表示"></a>等价类及其表示</h2><h3 id="等价关系与等价类"><a href="#等价关系与等价类" class="headerlink" title="等价关系与等价类"></a>等价关系与等价类</h3><p>先把每一个对象看作是一个单元素集合，然后依次将一个等价对中两个元素所在的集合合并。</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>指能够完成查找、合并功能的集合。<br>支持以下三种操作：</p>
<ol>
<li>Ufsets(n)：构造函数，将并查集中n个元素初始化为n个只有一个单元素的子集合。</li>
<li>Union(S1,S2)：把集合S2并入集合S1中。要求S1与S2互不相交，否则没有结果。</li>
<li>Find(d)：查找单元素d所在的集合，并返回该集合的名字。</li>
</ol>
<p><strong>等价类问题的解法</strong><br>    对于并查集来说，每个子集（等价类）用一棵树表示，子集合中每个元素用树中的一个结点表示。用树的根结点来代表相应的等价类集合。<br>    等价类树用双亲表示法表示（当然根据需要可以建立集合名字表示该集合的树的根结点之间的对应关系）；此外，树的根结点的双亲域的值设为-k（parent=-k），其中k为该树中的结点数（即所代表等价类中的元素数目）。<br>    对于任意给定的集合元素D，只要通过双亲指针向上一直走到树的根结点，就可以得到元素D所在的等价类（用根结点代表相应的等价类）。对于两个集合的并，只要将其中一个集合的根结点设置为另一个集合的根结点的孩子即可。</p>
<p><strong>性能改进</strong>——避免产生退化的树<br><em>Union(i,j)的加权规则WeightedUnion()</em>：合并两个集合时，先判断两集合中元素的个数，如果以i为根的树中的结点个数少于以j为根的树中的结点个数，则让j成为i的双亲；否则，让i成为j的双亲。<br>执行一次WeightedUnion()比执行一次Union()时间要多，但仍在常量界限O(1)范围内。查找操作Find()保持不变，其查找时间的上界不超过树的高度加1。</p>
<p><em>优化查找的折叠规则</em>：设j是以i为根的树中的一个结点，则对于从j到根i的路径上的每一个结点k，如果k的双亲不等于i，则把i设置为k的双亲。<br>使用折叠规则完成一次查找，所需时间比Find()多，但是能改善树的性能，减少以后查找操作所需的时间。</p>
<br/>

<hr>
<br/>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>无向图 undirected graph<br>有向图 directed graph<br>以下讨论限制于：图中不能有从顶点到自身的环（即自身环）；两个顶点v和w之间相关联的边不能多于一条。</p>
<br/>

<h3 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h3><ol>
<li>完全图 complete graph</li>
<li>权 weight</li>
<li>带权图=网络 network</li>
<li>邻接点 adjacent vertex</li>
<li>子图 subgraph</li>
<li>顶点的度 degree</li>
<li>路径 path</li>
<li>路径长度 path length</li>
<li>简单路径与回路 cycle</li>
<li>连通图与连通分量 connected graph and connected component</li>
<li>强连通图与强连通分量 strongly connected digraph</li>
<li>生成树 spanning tree</li>
</ol>
<br/>

<h3 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h3><ol>
<li>InsertVertex(d)</li>
<li>InsertEdge(v1,v2)</li>
<li>DeleteVertex(d)</li>
<li>DeleteEdge(v1,v2)</li>
<li>GetWeight(v1,v2)</li>
<li>GetFirstNeighbor(int v)</li>
<li>GetNextNeighbor(int v1,int v2)</li>
<li>Travers()</li>
<li>IsEmpty()</li>
</ol>
<br/>

<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><blockquote>
<p>顶点信息 —— 顶点表<br>顶点关系 —— 邻接矩阵</p>
</blockquote>
<p>N个定点的图其邻接矩阵是一个二维数组arcs[N][N]，定义如下。<br>[image:705B5107-1A6B-4C3A-AF6A-BE39846E0496-16898-0000936F10705A3B/D67FBC64-A83D-4414-B986-F6E0D1787DE3.png]<br>无向图的邻接矩阵一定是对称的，将第i行的元素值或第i列的元素值累加起来就得到顶点i的度。<br>有向图的邻接矩阵不一定对称，将第j列的所有元素值累加起来就得到顶点Vj的入度ID(Vj)；将第i行的所有元素值累加起来就得到顶点Vi的出度OD(Vi)。<br>对于网络（或带权图）邻接矩阵定义如下。<br>[image:C8816614-D7FC-4C3D-AB38-07F1F7D967D9-16898-00009392C7625CB8/56365ACE-F02E-4A11-98CA-FFCADDEF32AF.png]<br>对于带权有向图，第i行中所有非零且不等于∞的元素数目就是顶点i的出度；第j列中所有非零且不等于∞的元素数目就是顶点j的入度。</p>
<br/>

<p><strong>无向图邻接矩阵类模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AdjMatrixUndirGraph</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 邻接矩阵的数据成员:</span></span><br><span class="line">    <span class="keyword">int</span> vexNum, vexMaxNum, arcNum;          <span class="comment">// 顶点数目、允许的顶点最大数目和边数</span></span><br><span class="line">    <span class="keyword">int</span> **arcs;                             <span class="comment">// 存放边信息邻接矩阵</span></span><br><span class="line">    ElemType *vertexes;                     <span class="comment">// 存放顶点信息的数组 </span></span><br><span class="line">    <span class="keyword">mutable</span> Status *tag;                    <span class="comment">// 标志数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 邻接矩阵类型的方法声明:</span></span><br><span class="line">    AdjMatrixUndirGraph(ElemType es[], <span class="keyword">int</span> vertexNum, <span class="keyword">int</span> vertexMaxNum = DEFAULT_SIZE); </span><br><span class="line">        <span class="comment">// 以数组es[]为顶点,顶点个数为vertexNum,允许的顶点最大数目为vertexMaxNum,边数为0的无向图</span></span><br><span class="line">    AdjMatrixUndirGraph(<span class="keyword">int</span> vertexMaxNum = DEFAULT_SIZE);   </span><br><span class="line">        <span class="comment">// 构造允许的顶点最大数目为vertexMaxNum,边数为0的无向图</span></span><br><span class="line">    ~AdjMatrixUndirGraph();                 <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;                         <span class="comment">// 清空图             </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;                 <span class="comment">// 判断无向图是否为空 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetOrder</span><span class="params">(ElemType &amp;d)</span> <span class="keyword">const</span></span>;<span class="comment">// 求顶点的序号   </span></span><br><span class="line">    <span class="function">Status <span class="title">GetElem</span><span class="params">(<span class="keyword">int</span> v, ElemType &amp;d)</span> <span class="keyword">const</span></span>;<span class="comment">// 求顶点的元素值 </span></span><br><span class="line">    <span class="function">Status <span class="title">SetElem</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">const</span> ElemType &amp;d)</span></span>;<span class="comment">// 设置顶点的元素值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetVexNum</span><span class="params">()</span> <span class="keyword">const</span></span>;                  <span class="comment">// 返回顶点个数            </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetArcNum</span><span class="params">()</span> <span class="keyword">const</span></span>;                  <span class="comment">// 返回边数          </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">const</span></span>;       <span class="comment">// 返回顶点v的第一个邻接点          </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> <span class="keyword">const</span></span>;        <span class="comment">// 返回顶点v1的相对于v2的下一个邻接点          </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertVex</span><span class="params">(<span class="keyword">const</span> ElemType &amp;d)</span></span>;           <span class="comment">// 插入元素值为d的顶点       </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertArc</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;              <span class="comment">// 插入顶点为v1和v2的边             </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteVex</span><span class="params">(<span class="keyword">const</span> ElemType &amp;d)</span></span>;           <span class="comment">// 删除元素值为d的顶点           </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteArc</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;              <span class="comment">// 删除顶点为v1和v2的边             </span></span><br><span class="line">    <span class="function">Status <span class="title">GetTag</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">const</span></span>;                  <span class="comment">// 返回顶点v的标志         </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetTag</span><span class="params">(<span class="keyword">int</span> v, Status val)</span> <span class="keyword">const</span></span>;      <span class="comment">// 设置顶点v的标志为val       </span></span><br><span class="line">    AdjMatrixUndirGraph(<span class="keyword">const</span> AdjMatrixUndirGraph&lt;ElemType&gt; &amp;g);    <span class="comment">// 复制构造函数</span></span><br><span class="line">    AdjMatrixUndirGraph&lt;ElemType&gt; &amp;<span class="keyword">operator</span> =(<span class="keyword">const</span> AdjMatrixUndirGraph&lt;ElemType&gt; &amp;g); </span><br><span class="line">        <span class="comment">// 赋值语句重载</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>;                            <span class="comment">// 显示邻接矩阵无向图</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>是邻接矩阵的改进，把邻接矩阵的每一行改为一个单链表。<br>顶点结点：表示每一个顶点。其中保存着该顶点的嘻嘻和指向该结点相应的边（弧）链表的指针。用顺序表存储，假设顶点的序号为数组的下标。<br>对于<strong>无向图</strong>：<br>边链表：依附于同一个顶点的边链接在同一个单链表中。<br>边结点：边链表中的每一个结点代表一条边。其中保存着与该边相关联的另一个顶点的序号和指向同一链表中下一个边结点的指针。<br>对于<strong>有向图</strong>：<br>弧链表：从同一个顶点发出的弧链接在同一个单链表中。<br>弧结点：弧链表中的每一个结点代表一条弧。其中保存着该弧的弧头顶点序号和指向同一链表中下一个弧结点的指针。<br>对于<strong>带权图</strong>：<br>边（弧）结点中另保存该边（弧）上的权值。</p>
<br/>

<p>邻接表的边（弧）链表中，各个边（弧）结点的链入顺序是任意的，可根据边结点输入次序而定。<br>设图有n个顶点和e条边：用邻接表表示无向图时，需要n个顶点结点和2e个边结点；用邻接表表示有向图时，需要n个顶点结点和e个边结点（不考虑逆邻接表）。当e很小时，可以大量节省存储空间。<br>此外，把关联于同一个顶点的所有边（弧）链接在一个单链表中，可以大大方便图的操作。</p>
<br/>

<p><strong>有向网邻接表顶点结点类模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="title">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">AdjListNetWorkVex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 数据成员:</span></span><br><span class="line">    ElemType data;                      <span class="comment">// 数据元素值</span></span><br><span class="line">    AdjListNetworkArc&lt;WeightType&gt; *firstarc;</span><br><span class="line">        <span class="comment">// 指向邻接链表边结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数:</span></span><br><span class="line">    AdjListNetWorkVex();                <span class="comment">// 无参数的构造函数</span></span><br><span class="line">    AdjListNetWorkVex(ElemType val, </span><br><span class="line">        AdjListNetworkArc&lt;WeightType&gt; *adj = <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 有参数的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br/>

<p><strong>有向网邻接表弧结点类模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">AdjListNetworkArc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 数据成员:</span></span><br><span class="line">    <span class="keyword">int</span> adjVex;                             <span class="comment">// 弧头顶点序号</span></span><br><span class="line">    WeightType weight;                      <span class="comment">// 边的权值</span></span><br><span class="line">    AdjListNetworkArc&lt;WeightType&gt; *nextarc; <span class="comment">// 下一条边结点的指针 </span></span><br><span class="line"><span class="comment">// 构造函数:</span></span><br><span class="line">    AdjListNetworkArc();                    <span class="comment">// 无参数的构造函数</span></span><br><span class="line">    AdjListNetworkArc(<span class="keyword">int</span> v, WeightType w, AdjListNetworkArc&lt;WeightType&gt; * next = <span class="literal">NULL</span>);</span><br><span class="line">          <span class="comment">// 构造邻接点为v，权为w的邻接边</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br/>

<p><strong>有向网邻接表类模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="title">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AdjListDirNetwork</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 邻接表的数据成员:</span></span><br><span class="line">    <span class="keyword">int</span> vexNum, vexMaxNum, arcNum;                  <span class="comment">// 顶点数目、允许的顶点最大数目和边数</span></span><br><span class="line">    AdjListNetWorkVex&lt;ElemType, WeightType&gt; *vexTable;  <span class="comment">// 顶点表</span></span><br><span class="line">    <span class="keyword">mutable</span> Status *tag;                            <span class="comment">// 标志数组             </span></span><br><span class="line">    WeightType infinity;                            <span class="comment">// 无穷大的值 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span></span><br><span class="line">    AdjListDirNetwork(ElemType es[], <span class="keyword">int</span> vertexNum, <span class="keyword">int</span> vertexMaxNum = DEFAULT_SIZE, </span><br><span class="line">        WeightType infinit = (WeightType)DEFAULT_INFINITY);</span><br><span class="line">        <span class="comment">// 以数组es[]为顶点数据,顶点个数为vertexNum,允许的顶点最大数目为vertexMaxNum,</span></span><br><span class="line">        <span class="comment">// infinit表示无穷大,边数为0构造有向网</span></span><br><span class="line">    AdjListDirNetwork(<span class="keyword">int</span> vertexMaxNum = DEFAULT_SIZE, </span><br><span class="line">        WeightType infinit = (WeightType)DEFAULT_INFINITY);</span><br><span class="line">        <span class="comment">// 构造允许的顶点最大数目为vertexMaxNum,infinit表示无穷大,边数为0的有向网</span></span><br><span class="line">    ~AdjListDirNetwork();                        <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;                                <span class="comment">// 清空有向网            </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;                              <span class="comment">// 判断有向网是否为空 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetOrder</span><span class="params">(ElemType &amp;d)</span> <span class="keyword">const</span></span>;             <span class="comment">// 求顶点的序号  </span></span><br><span class="line">    <span class="function">Status <span class="title">GetElem</span><span class="params">(<span class="keyword">int</span> v, ElemType &amp;d)</span> <span class="keyword">const</span></span>;    <span class="comment">// 求顶点的元素值 </span></span><br><span class="line">    <span class="function">Status <span class="title">SetElem</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">const</span> ElemType &amp;d)</span></span>;    <span class="comment">// 设置顶点的元素值</span></span><br><span class="line">    <span class="function">WeightType <span class="title">GetInfinity</span><span class="params">()</span> <span class="keyword">const</span></span>;              <span class="comment">// 取无穷大的值           </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetVexNum</span><span class="params">()</span> <span class="keyword">const</span></span>;                       <span class="comment">// 求有向网的顶点个数            </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetArcNum</span><span class="params">()</span> <span class="keyword">const</span></span>;                       <span class="comment">// 求有向网的边数个数            </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">const</span></span>;                <span class="comment">// 求有向网中顶点v的第一个邻接点          </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> <span class="keyword">const</span></span>;        <span class="comment">// 求有向网中顶点v1的相对于v2的下一个邻接点           </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertVex</span><span class="params">(<span class="keyword">const</span> ElemType &amp;d)</span></span>;           <span class="comment">// 插入元素值为d的顶点       </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertArc</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, WeightType w)</span></span>;<span class="comment">// 插入从顶点为v1到v2、权为w的边            </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteVex</span><span class="params">(<span class="keyword">const</span> ElemType &amp;d)</span></span>;           <span class="comment">// 删除元素值为d的顶点           </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteArc</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;              <span class="comment">// 删除从顶点为v1到v2的边            </span></span><br><span class="line">    <span class="function">WeightType <span class="title">GetWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> <span class="keyword">const</span></span>;  <span class="comment">// 求从顶点为v1到v2的边的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, WeightType w)</span></span>;<span class="comment">// 设置从顶点为v1到v2的边的权值</span></span><br><span class="line">    <span class="function">Status <span class="title">GetTag</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">const</span></span>;                  <span class="comment">// 求顶点v的标志      </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetTag</span><span class="params">(<span class="keyword">int</span> v, Status tag)</span> <span class="keyword">const</span></span>;        <span class="comment">// 设置顶点v的标志为tag     </span></span><br><span class="line">    AdjListDirNetwork(<span class="keyword">const</span> AdjListDirNetwork&lt;ElemType, WeightType&gt; &amp;copy); <span class="comment">// 复制构造函数</span></span><br><span class="line">    AdjListDirNetwork&lt;ElemType, WeightType&gt; &amp;<span class="keyword">operator</span> =</span><br><span class="line">        (<span class="keyword">const</span> AdjListDirNetwork&lt;ElemType, WeightType&gt; &amp;copy); <span class="comment">// 重载赋值运算符 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>; <span class="comment">// 显示有向网邻接表 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>图的每一条边用一个边结点表示，由六个域组成。<br>标记域 tag 标记该边是否被处理过或搜索过<br>信息域 weight 存储边的权值<br>顶点域 adjvex1 adjvex2 该边所依附的两个顶点在图中的序号<br>链接指针 nextarc1 nextarc2 指向下一条依附于顶点adjvex1/adjvex2的边<br>顶点结点 包含data域存储有关顶点的信息、firstarc域指向第一条依附于该顶点的边 == 所有的顶点结点组成一个顺序表</p>
<br/>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>图的每一条边用一个弧结点表示，由六个域组成。<br>标记域 tag 标记该边是否被处理过或搜索过<br>信息域 weight 存储边的权值<br>顶点域 tailvex headvex 弧尾顶点序号和弧头顶点序号<br>链接指针 tailnextarc headnextarc 指向下一条以顶点tailvex为始点（弧尾）的弧和下一条以顶点headvex为终点（弧头）的弧<br>顶点结点 包含data域存储有关顶点的信息、firstinarc域指向第一条以该顶点为终点的弧、firstoutarc域指向第一条以该顶点为始点的弧 == 所有的顶点结点组成一个顺序表</p>
<br/>

<h2 id="图的遍历与连通性"><a href="#图的遍历与连通性" class="headerlink" title="图的遍历与连通性"></a>图的遍历与连通性</h2><p>对于给定的图，沿着一些边（弧）访问图中所有的顶点，且使每个顶点仅被访问一次。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p><strong>深度优先搜索</strong><br>1）访问结点v，并标记v已被访问。<br>2）取顶点v的第一个邻接顶点w。<br>3）若顶点w不存在，算法结束；否则继续步骤4）。<br>4）若顶点w未被访问，则访问结点w，并标记w已被访问。<br>5）使w为顶点v的在原来w之后的下一个邻接顶点，转到步骤3）。</p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">DFSTraverse</span>(<span class="title">const</span> <span class="title">AdjMatrixUndirGraph</span>&lt;ElemType&gt; &amp;<span class="title">g</span>, <span class="title">void</span> (*<span class="title">Visit</span>)(<span class="title">const</span> <span class="title">ElemType</span> &amp;))</span></span><br><span class="line"><span class="class">// 初始条件：存在图<span class="title">g</span></span></span><br><span class="line"><span class="class">// 操作结果：对无向图<span class="title">g</span>进行深度优先遍历</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)</span><br><span class="line">        g.SetTag(v, UNVISITED);<span class="comment">// 对每个顶点设置未访问标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (g.GetTag(v) == UNVISITED)</span><br><span class="line">            DFS(g, v , Visit);<span class="comment">// 从尚未访问的顶点v开始进行深度优先搜索 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">DFS</span>(<span class="title">const</span> <span class="title">AdjMatrixUndirGraph</span>&lt;ElemType&gt; &amp;<span class="title">g</span>, <span class="title">int</span> <span class="title">v</span>, <span class="title">void</span> (*<span class="title">Visit</span>)(<span class="title">const</span> <span class="title">ElemType</span> &amp;))</span></span><br><span class="line"><span class="class">// 初始条件：存在图<span class="title">g</span></span></span><br><span class="line"><span class="class">// 操作结果：从顶点<span class="title">v</span>出发进行深度优先搜索</span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    ElemType e; </span><br><span class="line">    g.SetTag(v, VISITED);       <span class="comment">// 设置顶点v已访问标志</span></span><br><span class="line">    g.GetElem(v, e);            <span class="comment">// 取顶点v的数据元素值 </span></span><br><span class="line">    Visit(e);                   <span class="comment">// 访问顶点v</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = g.FirstAdjVex(v); w != <span class="number">-1</span>; w = g.NextAdjVex(v, w))</span><br><span class="line">        <span class="keyword">if</span> (g.GetTag(w) == UNVISITED)</span><br><span class="line">            DFS(g, w , Visit);  <span class="comment">// 从v的尚未访问过的邻接顶点w开始进行深度优先搜索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>图中n个顶点，e条边。<br>存储结构为邻接表，时间复杂度为O(n+e)。<br>存储结构为邻接矩阵，时间复杂度为O(n^2)。</p>
<br/>

<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p><strong>广度优先搜索</strong><br>1）访问结点v，并标记v已被访问，同时顶点v入队列。<br>2）当队列空时算法结束，否则继续步骤3）。<br>3）队头顶点出队列为v。<br>4）取顶点v的第一个邻接顶点w。<br>5）若顶点w不存在，转步骤3）；否则继续步骤6）。<br>6）若顶点w未被访问，则访问结点w，并标记w已被访问，同时顶点w入队列；否则继续步骤7）。<br>7）使w为顶点v的在原来w之后的下一个邻接顶点，转到步骤5）。</p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BFSTraverse</span>(<span class="title">const</span> <span class="title">AdjMatrixUndirGraph</span>&lt;ElemType&gt; &amp;<span class="title">g</span>, <span class="title">void</span> (*<span class="title">Visit</span>)(<span class="title">const</span> <span class="title">ElemType</span> &amp;))</span></span><br><span class="line"><span class="class">// 初始条件：存在图<span class="title">g</span></span></span><br><span class="line"><span class="class">// 操作结果：对图<span class="title">g</span>进行广度优先遍历</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)</span><br><span class="line">        g.SetTag(v, UNVISITED); <span class="comment">// 对每个顶点作未访问标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)</span><br><span class="line">        <span class="keyword">if</span> (g.GetTag(v) == UNVISITED) </span><br><span class="line">            BFS(g, v , Visit);  <span class="comment">// 从尚未访问的顶点v开始进行广度优先搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BFS</span>(<span class="title">const</span> <span class="title">AdjMatrixUndirGraph</span>&lt;ElemType&gt; &amp;<span class="title">g</span>, <span class="title">int</span> <span class="title">v</span>, <span class="title">void</span> (*<span class="title">Visit</span>)(<span class="title">const</span> <span class="title">ElemType</span> &amp;))</span></span><br><span class="line"><span class="class">// 初始条件：存在图<span class="title">g</span></span></span><br><span class="line"><span class="class">// 操作结果：从顶点<span class="title">v</span>出发进行广度优先搜索</span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    LinkQueue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> u, w;</span><br><span class="line">    ElemType e;</span><br><span class="line">    g.SetTag(v, VISITED);                       <span class="comment">// 作访问标志</span></span><br><span class="line">    g.GetElem(v, e);                            <span class="comment">// 取顶点v的数据元素值 </span></span><br><span class="line">    Visit(e);                                   <span class="comment">// 访问顶点v</span></span><br><span class="line">    q.EnQueue(v);                               <span class="comment">// 顶点v入队 </span></span><br><span class="line">    <span class="keyword">while</span> (!q.IsEmpty())    &#123;   </span><br><span class="line">       q.DelQueue(u);</span><br><span class="line">       <span class="keyword">for</span> (w = g.FirstAdjVex(u); w != <span class="number">-1</span>; w = g.NextAdjVex(u, w))</span><br><span class="line">            <span class="keyword">if</span> (g.GetTag(w) == UNVISITED)&#123; <span class="comment">// 对u尚未访问过的邻接顶点w进行访问</span></span><br><span class="line">                g.SetTag(w, VISITED);   </span><br><span class="line">                g.GetElem(w, e);    </span><br><span class="line">                Visit(e);   </span><br><span class="line">                q.EnQueue(w);</span><br><span class="line">            &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>图中n个顶点，e条边。<br>存储结构为邻接表，时间复杂度为O(n+e)。<br>存储结构为邻接矩阵，时间复杂度为O(n^2)。</p>
<br/>

<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p>非连通图有k个连通分量，就要k次调用DFS或BFS才能访问图中的所有顶点。<br>深度优先生成森林、广度优先生成森林。</p>
<br/>

<h2 id="最小生成树-Minimum-cost-spanning-tree"><a href="#最小生成树-Minimum-cost-spanning-tree" class="headerlink" title="最小生成树 Minimum-cost spanning tree"></a>最小生成树 Minimum-cost spanning tree</h2><h3 id="克鲁斯卡尔算法-Kruskal"><a href="#克鲁斯卡尔算法-Kruskal" class="headerlink" title="克鲁斯卡尔算法 Kruskal"></a>克鲁斯卡尔算法 Kruskal</h3><p>避圈法<br>1）初始化，在并查集中，连通网络的每一个顶点独立成一个等价类，连通网络的所有的边建立最小堆，最小生成树T中没有任何边，T中边的条数计数器i为0。<br>2）如果T中边的条数计数器i等于顶点数减1，则算法结束；否则继续步骤3）。<br>3）选取堆顶元素代表的边(v,u)，同时调整堆。<br>4）利用并查集的运算检查依附于边(v,u)的两个顶点v和u是否在同一个连通分量（即并查集的同一个子集合）上，如果是则转步骤2）；否则继续步骤5）。<br>5）将边(v,u)加入到最小生成树T中，同时将这两个顶点所在的连通分量合并成一个连通分量（即并查集中的相应两个子集合并成一个子集），继续步骤2）。</p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="title">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MiniSpanTreeKruskal</span>(<span class="title">const</span> <span class="title">AdjMatrixUndirNetwork</span>&lt;ElemType, WeightType&gt; &amp;<span class="title">g</span>)</span></span><br><span class="line"><span class="class">// 初始条件：存在网<span class="title">g</span></span></span><br><span class="line"><span class="class">// 操作结果：用<span class="title">Kruskal</span>算法构造网<span class="title">g</span>的最小代价生成树</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count, VexNum = g.GetVexNum();</span><br><span class="line">    KruskalEdge&lt;ElemType, WeightType&gt; KEdge;</span><br><span class="line">    MinHeap&lt;KruskalEdge&lt;ElemType, WeightType&gt; &gt; ha(g.GetEdgeNum());</span><br><span class="line">    ElemType  *kVex, v1, v2;</span><br><span class="line">    kVex = <span class="keyword">new</span> ElemType[VexNum];    <span class="comment">// 定义顶点数组,存储顶点信息 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VexNum; i++)</span><br><span class="line">        g.GetElem(i, kVex[i]);</span><br><span class="line">    <span class="function">UFSets&lt;ElemType&gt; <span class="title">f</span><span class="params">(kVex,VexNum)</span></span>;<span class="comment">// 根据顶点数组构造并查集 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = g.FirstAdjVex(v); u &gt;= <span class="number">0</span>; u = g.NextAdjVex(v, u))</span><br><span class="line">            <span class="keyword">if</span> (v &lt; u)          &#123;   <span class="comment">// 将v &lt; u的边插入到最小堆 </span></span><br><span class="line">                g.GetElem(v, v1); </span><br><span class="line">                g.GetElem(u, v2);</span><br><span class="line">                KEdge.vertex1 = v1;</span><br><span class="line">                KEdge.vertex2 = v2;</span><br><span class="line">                KEdge.weight = g.GetWeight(v,u);</span><br><span class="line">                ha.Insert(KEdge);</span><br><span class="line">            &#125;</span><br><span class="line">    count = <span class="number">0</span>;                      <span class="comment">// 表示已经挑选的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt; VexNum - <span class="number">1</span>)  &#123;   </span><br><span class="line">        ha.DeleteTop(KEdge);        <span class="comment">// 从堆顶取一条边</span></span><br><span class="line">        v1 = KEdge.vertex1;</span><br><span class="line">        v2 = KEdge.vertex2;</span><br><span class="line">        <span class="keyword">if</span> (f.Differ(v1, v2))   &#123;   <span class="comment">// 边所依附的两顶点不在同一棵树上</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"边:( "</span> &lt;&lt; v1 &lt;&lt; <span class="string">", "</span> &lt;&lt; v2 &lt;&lt; <span class="string">" ) 权:"</span> &lt;&lt; KEdge.weight &lt;&lt; <span class="built_in">endl</span> ; <span class="comment">// 输出边及权值</span></span><br><span class="line">            f.Union(v1, v2);        <span class="comment">// 将两个顶点所在的树合并成一棵树</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>连通网络中n个顶点，e条边。<br>初始建堆，需要e次调用堆的插入操作，时间复杂度为O(elog2e)。<br>构造最小生成树，最多调用e次堆的删除操作、2e次并查集的查找操作和n-1次并查集的合并操作，时间复杂度分别为O(elog2e)、O(elog2e)和O(n)。<br>总时间复杂度O(elog2e)。<br>Kruskal算法适用于稀疏的（顶点个数较多而边数较少）连通网络。</p>
<br/>

<h3 id="普里姆算法-Prim"><a href="#普里姆算法-Prim" class="headerlink" title="普里姆算法 Prim"></a>普里姆算法 Prim</h3><p>1）输入：一个加权连通图，其中顶点集合为V，边集合为E；<br>2）初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}，为空；<br>3）重复下列操作，直到Vnew = V：<br>    a.在集合E中选取权值最小的边&lt;u, v&gt;，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；<br>    b.将v加入集合Vnew中，将&lt;u, v&gt;边加入集合Enew中；<br>4）输出：使用集合Vnew和Enew来描述所得到的最小生成树。</p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="title">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MiniSpanTreePrim</span>(<span class="title">const</span> <span class="title">AdjMatrixUndirNetwork</span>&lt;ElemType, WeightType&gt; &amp;<span class="title">g</span>, <span class="title">int</span> <span class="title">u0</span>)</span></span><br><span class="line"><span class="class">// 初始条件：存在网<span class="title">g</span>,<span class="title">u0</span>为<span class="title">g</span>的一个顶点</span></span><br><span class="line"><span class="class">// 操作结果：用<span class="title">Prim</span>算法从<span class="title">u0</span>出发构造网<span class="title">g</span>的最小代价生成树</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   WeightType min;</span><br><span class="line">   ElemType v1, v2;</span><br><span class="line">   <span class="keyword">int</span> vexnum = g.GetVexNum();</span><br><span class="line">   CloseArcType&lt;ElemType, WeightType&gt; * closearc;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (u0 &lt; <span class="number">0</span> || u0 &gt;= vexnum)</span><br><span class="line">      <span class="keyword">throw</span> Error(<span class="string">"顶点u0不存在!"</span>); <span class="comment">// 抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v, k;                        <span class="comment">// 表示顶点的临时变量 </span></span><br><span class="line">    closearc = <span class="keyword">new</span> CloseArcType&lt;ElemType, WeightType&gt;[vexnum];  <span class="comment">// 分配存储空间</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; vexnum; v++)    &#123;   <span class="comment">// 初始化辅助数组adjVex，并对顶点作标志，此时U = &#123;v0&#125;</span></span><br><span class="line">        closearc[v].nearvertex = u0;</span><br><span class="line">        closearc[v].lowweight = g.GetWeight(u0, v);</span><br><span class="line">    &#125;</span><br><span class="line">    closearc[u0].nearvertex = <span class="number">-1</span>;</span><br><span class="line">    closearc[u0].lowweight = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; vexnum; k++) &#123;  <span class="comment">// 选择生成树的其余g.GetVexNum() - 1个顶点</span></span><br><span class="line">        min = g.GetInfinity();</span><br><span class="line">        v = u0;<span class="comment">// 选择使得边&lt;w, adjVex[w]&gt;为连接V-U到U的具有最小权值的边</span></span><br><span class="line">        <span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; vexnum; u++)</span><br><span class="line">           <span class="keyword">if</span> (closearc[u].lowweight != <span class="number">0</span> &amp;&amp; closearc[u].lowweight &lt; min) &#123;</span><br><span class="line">              v = u;</span><br><span class="line">              min = closearc[u].lowweight;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">if</span> (v != u0) &#123;</span><br><span class="line">           g.GetElem(closearc[v].nearvertex, v1);</span><br><span class="line">           g.GetElem(v, v2);     </span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="string">"边:( "</span> &lt;&lt; v1 &lt;&lt; <span class="string">", "</span> &lt;&lt;  v2 &lt;&lt; <span class="string">" ) 权:"</span> &lt;&lt; min &lt;&lt; <span class="built_in">endl</span> ; <span class="comment">// 输出边及权值</span></span><br><span class="line">           closearc[v].lowweight = <span class="number">0</span>;       <span class="comment">// 将w并入U</span></span><br><span class="line">           <span class="keyword">for</span> (u = g.FirstAdjVex(v); u != <span class="number">-1</span> ; u = g.NextAdjVex(v, u))     <span class="comment">// 新顶点并入U后重新选择最小边</span></span><br><span class="line">              <span class="keyword">if</span> (closearc[u].lowweight != <span class="number">0</span> &amp;&amp; (g.GetWeight(v, u) &lt; closearc[u].lowweight))    &#123;   <span class="comment">// &lt;v, w&gt;为新的最小边</span></span><br><span class="line">                closearc[u].lowweight = g.GetWeight(v, u);</span><br><span class="line">                closearc[u].nearvertex = v;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []closearc;          <span class="comment">// 释放存储空间  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>连通网络中n个顶点，e条边。<br>辅助数组closearc[]初始化，n-1次for循环，时间复杂度为O(n)。<br>把n-1个顶点加入U中，对每加入一个顶点到U，有两个并列的for循环分别实现查找具有最小权值的边和修改辅助数组closearc[]，时间复杂度均为O(n)。<br>总时间复杂度O(n^2)。<br>Prim算法适用于边稠密的连通网络。</p>
<br/>

<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="弧上权值为非负情形的单源点最短路径问题-——-Dijkstra"><a href="#弧上权值为非负情形的单源点最短路径问题-——-Dijkstra" class="headerlink" title="弧上权值为非负情形的单源点最短路径问题 —— Dijkstra"></a>弧上权值为非负情形的单源点最短路径问题 —— Dijkstra</h3><p>根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合，集合中所有的点的d[i]都是该点到初始点最短路径长度，由于后加入的点是根据集合S中的点为基础拓展的，所以也能找到最短路径。<br>1）清除所有点的标号;<br>2）设d[0]=0，其他d[i]=INF;   //INF是一个很大的值，用来替代正无穷<br>3）循环n次<br>    {<br>    在所有未标号结点中，选出d值最小的结点x;<br>    给结点x标记;<br>    对于从x出发的所有边(x,y)，更新d[y] = min{d[y], d[x]+w(x,y)  }</p>
<br/>

<p><a href="https://blog.csdn.net/qq_39521554/article/details/79333690" target="_blank" rel="noopener">简单易懂——Dijkstra算法讲解_Machine Learning with Turing’s Cat-CSDN博客</a><br><a href="https://www.jianshu.com/p/152427566911" target="_blank" rel="noopener">数据结构（十二）：最短路径(Dijkstra算法) - 简书</a></p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="title">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ShortestPathDij</span>(<span class="title">const</span> <span class="title">AdjListDirNetwork</span>&lt;ElemType, WeightType&gt; &amp;<span class="title">g</span>, <span class="title">int</span> <span class="title">v0</span>, </span></span><br><span class="line"><span class="class">    <span class="title">int</span> *<span class="title">path</span>, <span class="title">WeightType</span> *<span class="title">dist</span>)</span></span><br><span class="line"><span class="class">// 操作结果:</span> 用Dijkstra算法求有向网g从顶点v0到其余顶点v的最短路径path和路径长度dist[v],</span><br><span class="line"><span class="comment">//  path[v]存储最短路径上终点的前一顶点的顶点号</span></span><br><span class="line">&#123;</span><br><span class="line">    WeightType minVal, infinity = g.GetInfinity();</span><br><span class="line">    <span class="keyword">int</span> v, u;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)&#123;    <span class="comment">// 初始化path和dist及顶点标志</span></span><br><span class="line">        dist[v] = (v0 != v) ? g.GetWeight(v0, v) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dist[v] == infinity)</span><br><span class="line">            path[v] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            path[v] = v0;</span><br><span class="line">        g.SetTag(v, UNVISITED); <span class="comment">// 置顶点标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    g.SetTag(v0, VISITED);      <span class="comment">// U=&#123;v0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; g.GetVexNum(); i++)&#123;    <span class="comment">// 求g.GetVexNum() - 1个顶点的最短路径  </span></span><br><span class="line">        minVal = infinity;</span><br><span class="line">        u = v0;</span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)   <span class="comment">// 查找最小的最短路径 </span></span><br><span class="line">            <span class="keyword">if</span> (g.GetTag(v) == UNVISITED &amp;&amp; dist[v] &lt; minVal)       &#123;</span><br><span class="line">                <span class="comment">// g.GetTag(v) == UNVISITED表示v∈V - U</span></span><br><span class="line">                u = v;</span><br><span class="line">                minVal = dist[v];</span><br><span class="line">            &#125;</span><br><span class="line">        g.SetTag(u, VISITED);   <span class="comment">// 将u并入U</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (v = g.FirstAdjVex(u); v != <span class="number">-1</span>; v = g.NextAdjVex(u, v))</span><br><span class="line">            <span class="keyword">if</span> (g.GetTag(v) == UNVISITED &amp;&amp; minVal + g.GetWeight(u, v) &lt; dist[v])   &#123;</span><br><span class="line">                <span class="comment">// 如v∈V - U且minVal + g.GetWeight(u, v) &lt; dist[v],则修改dist[v]及path[v]</span></span><br><span class="line">                dist[v] = minVal + g.GetWeight(u, v);</span><br><span class="line">                path[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="弧上权值为任意值的单源点最短路径问题（自学）——-BellmanFord"><a href="#弧上权值为任意值的单源点最短路径问题（自学）——-BellmanFord" class="headerlink" title="弧上权值为任意值的单源点最短路径问题（自学）—— BellmanFord"></a>弧上权值为任意值的单源点最短路径问题（自学）—— BellmanFord</h3><br/>

<p><a href="https://www.jianshu.com/p/b876fe9b2338" target="_blank" rel="noopener">数据结构（十一）：最短路径(Bellman-Ford算法) - 简书</a></p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="title">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ShortestPathBellmanFord</span>(<span class="title">const</span> <span class="title">AdjListDirNetwork</span>&lt;ElemType, WeightType&gt; &amp;<span class="title">g</span>, <span class="title">int</span> <span class="title">v0</span>, </span></span><br><span class="line"><span class="class">    <span class="title">int</span> *<span class="title">path</span>, <span class="title">WeightType</span> *<span class="title">dist</span>)</span></span><br><span class="line"><span class="class">// 操作结果:</span> 用BellmanFord算法求有向网g从顶点v0到其余顶点v的最短路径path和路径长度dist[v],</span><br><span class="line"><span class="comment">//  path[v]存储最短路径上终点的前一顶点的顶点号</span></span><br><span class="line">&#123;</span><br><span class="line">    WeightType *distTemp, minVal, infinity = g.GetInfinity();</span><br><span class="line">    <span class="keyword">int</span> v, u, vexNum = g.GetVexNum();</span><br><span class="line">    distTemp = <span class="keyword">new</span> WeightType[vexNum];</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; vexNum; v++)&#123;   <span class="comment">// 初始化path和dist</span></span><br><span class="line">        dist[v] = (v0 != v) ? g.GetWeight(v0, v) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dist[v] == infinity)</span><br><span class="line">            path[v] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            path[v] = v0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span>  k = <span class="number">2</span>; k &lt; vexNum ; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; vexNum; v++)</span><br><span class="line">            distTemp[v] = dist[v];</span><br><span class="line">        <span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; vexNum ; u++) </span><br><span class="line">            <span class="keyword">if</span> (u != v0)</span><br><span class="line">                <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; vexNum; v++) </span><br><span class="line">                    <span class="keyword">if</span> (v != v0 &amp;&amp; distTemp[u] &gt; dist[v] + g.GetWeight(v, u)) &#123;</span><br><span class="line">                        distTemp[u]= dist[v] + g.GetWeight(v, u);</span><br><span class="line">                        path[u] = v;</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; vexNum; v++)</span><br><span class="line">            dist[v] = distTemp[v];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="所有顶点之间的最短路径-——-Floyd"><a href="#所有顶点之间的最短路径-——-Floyd" class="headerlink" title="所有顶点之间的最短路径 —— Floyd"></a>所有顶点之间的最短路径 —— Floyd</h3><p>通过一个图的权值矩阵 求出它的每两点间的最短路径矩阵。<br>从图的带权邻接矩阵A=[a(i,j)] n×n开始，递归地进行n次更新，即由矩阵D(0)=A，按一个公式，构造出矩阵D(1)；又用同样地公式由D(1)构造出D(2)；……；最后又用同样的公式由D(n-1)构造出矩阵D(n)。矩阵D(n)的i行j列元素便是i号顶点到j号顶点的最短路径长度，称D(n)为图的距离矩阵 ，同时还可引入一个后继节点矩阵path来记录两点间的最短路径。<br>采用松弛技术（松弛操作），对在i和j之间的所有其他点进行一次松弛。所以时间复杂度为O(n^3);<br>空间复杂度为O(n^2)。</p>
<br/>

<p><a href="https://www.jianshu.com/p/9133919e6e4c" target="_blank" rel="noopener">数据结构（十三）：最短路径(Floyd算法) - 简书</a></p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="title">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ShortestPathFloyd</span>(<span class="title">const</span> <span class="title">AdjListDirNetwork</span>&lt;ElemType, WeightType&gt; &amp;<span class="title">g</span>, <span class="title">int</span> **<span class="title">path</span>, </span></span><br><span class="line"><span class="class">    <span class="title">WeightType</span> **<span class="title">dist</span>)</span></span><br><span class="line"><span class="class">// 操作结果:</span> 用Floyd算法求有向网g中各对顶点u和v之间的最短路径path[u][v]和路径长度</span><br><span class="line"><span class="comment">//  dist[u][v],path[u][v]存储从u到v的最短路径上至此顶点的前一顶点的顶点号,dist[u][v]</span></span><br><span class="line"><span class="comment">//  存储从u到v的最短路径的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; g.GetVexNum(); u++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)</span><br><span class="line">        &#123;   <span class="comment">// 初始化path和dist</span></span><br><span class="line">            dist[u][v] = (u != v) ? g.GetWeight(u, v) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (u != v &amp;&amp; dist[u][v] &lt; g.GetInfinity())</span><br><span class="line">               path[u][v] = u;  <span class="comment">// 存在边&lt;u,v&gt;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               path[u][v] = <span class="number">-1</span>;                                         <span class="comment">// 不存在边&lt;u,v&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; g.GetVexNum(); k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.GetVexNum(); i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.GetVexNum(); j++)</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    <span class="comment">// 从i到k再到j的路径长度更短</span></span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j]; </span><br><span class="line">                    path[i][j] = path[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="活动网络"><a href="#活动网络" class="headerlink" title="活动网络"></a>活动网络</h2><h3 id="用顶点表示活动的网络-AOV-——-拓扑排序"><a href="#用顶点表示活动的网络-AOV-——-拓扑排序" class="headerlink" title="用顶点表示活动的网络 AOV —— 拓扑排序"></a>用顶点表示活动的网络 AOV —— 拓扑排序</h3><p>Activity On Vertex<br>AOV网络中不能出现有向回路（有向环）。<br>对AOV网络构造它的拓扑有序序列，即将AOV网络中的各个顶点排列成一个线性有序的序列，使得AOV网络中所有的前驱和后继关系都能得到满足。<br>拓扑排序 &lt;==&gt; 没有有向环<br>一个AOV网络的拓扑有序序列不是唯一的。</p>
<br/>

<p><strong>拓扑排序简单方法</strong><br>1）在AOV网络中选一个没有直接前驱的顶点v；并输出之。<br>2）从图中删去该顶点，同时删去所有从顶点v发出的弧。<br>3）重复以上步骤1）和2），直到没有直接前驱的顶点全部输出。如果图中所有顶点已全部输出，则拓扑有序序列形成，拓扑排序完成；否则说明图中还剩下一些顶点，它们都有直接前驱，再也找不到没有前驱的顶点了，这时AOV网络必定存在有向环。</p>
<br/>

<p><strong>使用栈（或队列）的拓扑排序算法</strong><br>1）建立入度为零的顶点栈。<br>2）当入度为零的顶点栈为空时算法转步骤6），否则继续步骤3）。<br>3）入度为零的顶点栈中栈顶元素v出栈，并输出之顶点v。<br>4）从AOV网络中删去顶点v和多有从顶点v发出的弧&lt;v,j&gt;，并将顶点j的入度减1。<br>5）如果顶点j入度减至0，则将该顶点进入入度为零的顶点栈；转步骤2）。<br>6）如果输出顶点个数少于AOV网络的顶点个数，则输出网络中存在有向环的信息；算法结束。<br><em>为了建立入度为零的顶点栈，可以不另外分配存储空间，直接利用顶点的入度数组InDegree[]中入度为零的元素，建立入度为零的静态链栈。</em></p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Status</span> <span class="title">TopSort</span>(<span class="title">const</span> <span class="title">AdjListDirGraph</span>&lt;ElemType&gt; &amp;<span class="title">g</span>)</span></span><br><span class="line"><span class="class">// 初始条件：存在有向图<span class="title">g</span></span></span><br><span class="line"><span class="class">// 操作结果：如<span class="title">g</span>无回路,则输出<span class="title">g</span>的顶点的一个拓扑序列,并返回<span class="title">SUCCESS</span>,否则返回<span class="title">FAIL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *indegree = <span class="keyword">new</span> <span class="keyword">int</span>[g.GetVexNum()]; <span class="comment">// 顶点入度数组       </span></span><br><span class="line">    <span class="keyword">int</span> v, u, count = <span class="number">0</span>, top = <span class="number">-1</span>;</span><br><span class="line">    ElemType e;</span><br><span class="line">    StatIndegree(g, indegree);              <span class="comment">// 统计顶点的入度</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)</span><br><span class="line">        <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>)  &#123;            <span class="comment">// 入度为0的顶点入栈 </span></span><br><span class="line">            indegree[v] = top;</span><br><span class="line">            top = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)   &#123;   <span class="comment">// 栈非空</span></span><br><span class="line">        v = top;</span><br><span class="line">        top = indegree[v];</span><br><span class="line">        g.GetElem(v, e);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">        count++;            <span class="comment">// 对输出顶点进行记数</span></span><br><span class="line">        <span class="keyword">for</span> (u = g.FirstAdjVex(v); u != <span class="number">-1</span>; u = g.NextAdjVex(v, u))</span><br><span class="line">            <span class="comment">// 对v的每个邻接点u入度减1</span></span><br><span class="line">            <span class="keyword">if</span> (--indegree[u] == <span class="number">0</span>) &#123;<span class="comment">// u入度为0,将u入栈</span></span><br><span class="line">               indegree[u] = top;</span><br><span class="line">               top = u;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []indegree;                      <span class="comment">// 释放indegree所占用的存储空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &lt; g.GetVexNum()) <span class="keyword">return</span> FAIL; <span class="comment">// 图g有回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> SUCCESS;                    <span class="comment">// 拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>AOV网络中n个顶点，e条边。<br>搜索入度为零的顶点建立链栈，for循环，时间复杂度为O(n)。<br>（网络中没有回路）所有顶点都需要进一次栈，出一次栈，时间复杂度为O(n)。<br>顶点入度减1的运算，执行e次，时间复杂度O(e)。<br>总时间复杂度O(n+e)。</p>
<br/>

<h3 id="用边表示活动的网络-AOE-——-关键路径"><a href="#用边表示活动的网络-AOE-——-关键路径" class="headerlink" title="用边表示活动的网络 AOE —— 关键路径"></a>用边表示活动的网络 AOE —— 关键路径</h3><p>Activity On Edges<br>AOE网络中不能出现有向回路（有向环）。<br>AOE网络中不能出现多个入度为0的顶点。<br>AOE网络中只有一个入度为0的顶点（称为源点）用于彼岸是这个开始事件；只有一个出度为0的顶点（称为汇点）用于表示这个完成事件。由于活动有先后或并行，从源点到汇点的路径可能不止一条，相应路径上所有活动的持续时间之和可能是不同的，但只有当各条路径上的所有活动都完成了，整个工程才算完成。整个工程完成所需的最短时间取决于<strong>从源点到汇点的最长路径长度</strong>，这条路径最长的路径就叫做<strong>关键路径</strong>（critical path），关键路径上的所有活动都是<strong>关键活动</strong>（即不按期完成就会影响整个工程完成的活动）。<br>定义以下相关量找出关键活动：<br>1）事件Vi的最早可能发生时间Ve[i]（V early）<br>2）事件Vi的最迟允许发生时间Vl[i]（V late）<br>3）活动ak的最早可能开始时间e[k]<br>4）活动ak的最迟允许开始时间l[k]<br>5）活动ak的时间余量l[k]-e[k]（时间余量为零的活动室关键活动）</p>
<br/>

<p><strong>计算关键路径的算法步骤</strong><br>1）输入n个顶点和e条带权的有向边，建立邻接表结构。<br>2）从源点V0出发，令Ve[0]=0，按拓扑有序的顺序计算每个顶点的Ve[j]（j=1,2,…,n-1）。若拓扑排序中遍历的顶点数小于n，则说明网络中存在有向环，不能继续求关键路径。<br>3）从汇点Vn-1出发，令Vl[n-1]=Ve[n-1]，按拓扑有序顺序求各顶点的Vl[i]（i=0,1,…,n-2）。<br>4）根据各顶点Vi和Ve[i]和Vl[i]的值，求各条弧ak的e[k]和l[k]。<br>5）输出关键活动ak（e[k]==l[k]即为关键活动）。</p>
<br/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="title">class</span> <span class="title">WeightType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Status</span> <span class="title">CriticalPath</span>(<span class="title">const</span> <span class="title">AdjListDirNetwork</span>&lt;ElemType, WeightType&gt; &amp;<span class="title">g</span>)</span></span><br><span class="line"><span class="class">// 初始条件：存在有向网<span class="title">g</span></span></span><br><span class="line"><span class="class">// 操作结果：如<span class="title">g</span>无回路,则输出<span class="title">g</span>的关键活动,并返回<span class="title">SUCCESS</span>,否则返回<span class="title">FAIL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *indegree = <span class="keyword">new</span> <span class="keyword">int</span>[g.GetVexNum()]; <span class="comment">// 顶点入度数组</span></span><br><span class="line">    WeightType *ve = <span class="keyword">new</span> <span class="keyword">int</span>[g.GetVexNum()];    <span class="comment">// 事件最早发生时刻数组</span></span><br><span class="line">    WeightType *vl = <span class="keyword">new</span> <span class="keyword">int</span>[g.GetVexNum()];  <span class="comment">// 事件最迟发生时刻数组</span></span><br><span class="line">    LinkQueue&lt;<span class="keyword">int</span>&gt; q;                   <span class="comment">// 用于存储入度为0的顶点</span></span><br><span class="line">    LinkStack&lt;<span class="keyword">int</span>&gt; s;                   <span class="comment">// 用于实现逆扑序序列的栈</span></span><br><span class="line">    <span class="keyword">int</span> ee, el, u, v, count = <span class="number">0</span>;</span><br><span class="line">    ElemType e1, e2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)     <span class="comment">// 初始化事件最早发生时刻</span></span><br><span class="line">        ve[v] = <span class="number">0</span>;</span><br><span class="line">    StatIndegree(g, indegree);              <span class="comment">// 统计顶点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++) <span class="comment">// 遍历顶点</span></span><br><span class="line">        <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>)   <span class="comment">// 建立入度为0的顶点队列</span></span><br><span class="line">            q.EnQueue(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.IsEmpty())    &#123;   <span class="comment">// 队列非空</span></span><br><span class="line">        q.DelQueue(u);          <span class="comment">// 取出一个入度为0的顶点</span></span><br><span class="line">        s.Push(u);              <span class="comment">// 顶点u入栈,以便得逆拓扑排序序列</span></span><br><span class="line">        count++;                <span class="comment">// 对顶点进行记数</span></span><br><span class="line">        <span class="keyword">for</span> (v = g.FirstAdjVex(u); v != <span class="number">-1</span>; v = g.NextAdjVex(u, v))     &#123;</span><br><span class="line">            <span class="comment">// v为弧&lt;u,v&gt;的弧头顶点,对u的每个邻接点入度减1</span></span><br><span class="line">            <span class="keyword">if</span> (--indegree[v] == <span class="number">0</span>) <span class="comment">// v入度为0,将v入队</span></span><br><span class="line">                q.EnQueue(v);</span><br><span class="line">            <span class="keyword">if</span> (ve[u] + g.GetWeight(u, v) &gt; ve[v])  <span class="comment">// 修改ve[v]</span></span><br><span class="line">                ve[v] = ve[u] + g.GetWeight(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []indegree;          <span class="comment">// 释放indegree所占用的存储空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &lt; g.GetVexNum())  &#123;</span><br><span class="line">        <span class="keyword">delete</span> []ve;            <span class="comment">// 释放ve所占用的存储空间</span></span><br><span class="line">        <span class="keyword">return</span> FAIL;            <span class="comment">// 网g有回路</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.Top(u);                               <span class="comment">// 取出栈顶,栈顶为汇点</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; g.GetVexNum(); v++)     <span class="comment">// 初始化事件最迟发生时刻</span></span><br><span class="line">        vl[v] = ve[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.IsEmpty())      &#123; <span class="comment">// s非空</span></span><br><span class="line">        s.Pop(u);</span><br><span class="line">        <span class="keyword">for</span> (v = g.FirstAdjVex(u); v != <span class="number">-1</span>; v = g.NextAdjVex(u, v)) <span class="comment">// v为u的一个邻接点</span></span><br><span class="line">            <span class="keyword">if</span> (vl[v] - g.GetWeight(u, v) &lt; vl[u])  <span class="comment">// 修改vl[u]</span></span><br><span class="line">                vl[u] = vl[v] - g.GetWeight(u, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; g.GetVexNum(); u++) &#123;   <span class="comment">// 求ee, el和关键路径</span></span><br><span class="line">        <span class="keyword">for</span> (v = g.FirstAdjVex(u); v != <span class="number">-1</span>; v = g.NextAdjVex(u, v))     &#123;   <span class="comment">// v为u的一个邻接点</span></span><br><span class="line">            ee = ve[u]; el = vl[v] - g.GetWeight(u, v);</span><br><span class="line">            <span class="keyword">if</span> (ee == el)   &#123;   <span class="comment">// &lt;u, v&gt;为关键活动</span></span><br><span class="line">                g.GetElem(u, e1);</span><br><span class="line">                g.GetElem(v, e2);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; e1 &lt;&lt; <span class="string">","</span> &lt;&lt; e2 &lt;&lt; <span class="string">"&gt; "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> []ve;                <span class="comment">// 释放ve所占用的存储空间</span></span><br><span class="line">    <span class="keyword">delete</span> []vl;                <span class="comment">// 释放vl所占用的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;             <span class="comment">// 操作成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>AOE网络中n个顶点，e条边。<br>求各顶点的Ve[i]和Vl[i]，时间复杂度为O(n+e)。<br>求各个活动的e[k]和l[k]，时间复杂度为O(n+e)。<br>总时间复杂度O(n+e)。<br><strong>不是任一关键活动加速就一定能使整个工程提前完成。</strong><br><strong>在存在多条关键路径的情况下，只有加快那些处在所有关键路径上的公共关键活动的进度，才能提前完成整个工程。而这些关键活动的加速是有限度的，即不能改变关键路径。</strong></p>
<br/>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Yijun Lin</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/">http://yoursite.com/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/ComputerScience/"># ComputerScience</a>
                    
                        <a href="/tags/DataStructure/"># DataStructure</a>
                    
                        <a href="/tags/Review/"># Review</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/02/07/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/">StudyNote | Python网络爬虫与信息提取</a>
            
            
            <a class="next" rel="next" href="/2020/01/23/%E5%9B%BE%E8%A7%A3TCP:IP/">StudyNote | 图解TCP/IP</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Yijun Lin | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
